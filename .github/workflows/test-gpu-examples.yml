name: Build and run GPU integrated tests (examples)

on:
  workflow_dispatch:
  push:
    branches: ["*"]
  pull_request:
    branches: ["master", "main"]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.event_name }}
  cancel-in-progress: true

env:
  BPFTIME_VM_NAME: llvm

jobs:
  build-and-test-gpu-examples:
    runs-on: [self-hosted, Linux, X64, gpu]
    strategy:
      fail-fast: false
      matrix:
        examples:
          - path: kernelretsnoop
            executable: ./kernelretsnoop
            victim: ./vec_add
            expected_str: "Thread ("
            name: kernelretsnoop
            server_timeout: 15
          - path: gpu_shard_array
            executable: ./gpu_shard_array
            victim: ./vec_add
            expected_str: "counter[0]="
            name: gpu-shard-array
            server_timeout: 20
          - path: threadhist
            executable: ./threadhist
            victim: ./vec_add
            expected_str: "Thread "
            name: threadhist
            server_timeout: 15
          - path: cuda-counter
            executable: ./cuda_probe
            victim: ./vec_add
            expected_str: "Entered _Z9vectorAddPKfS0_Pf"
            name: cuda-counter
            server_timeout: 15
          - path: launchlate
            executable: ./launchlate
            victim: ./vec_add
            expected_str: "Monitoring CUDA kernel launch latency"
            name: launchlate
            server_timeout: 15
          - path: mem_trace
            executable: ./mem_trace
            victim: ./vec_add
            expected_str: "mem_traces:"
            name: mem_trace
            server_timeout: 15

    steps:
      - name: Configure proxy for China
        run: |
          echo "Setting up proxy for China network..."
          export http_proxy=http://192.168.15.1:2345
          export https_proxy=http://192.168.15.1:2345
          export HTTP_PROXY=http://192.168.15.1:2345
          export HTTPS_PROXY=http://192.168.15.1:2345
          export no_proxy=localhost,127.0.0.1,192.168.0.0/16
          echo "http_proxy=http://192.168.15.1:2345" >> $GITHUB_ENV
          echo "https_proxy=http://192.168.15.1:2345" >> $GITHUB_ENV
          echo "HTTP_PROXY=http://192.168.15.1:2345" >> $GITHUB_ENV
          echo "HTTPS_PROXY=http://192.168.15.1:2345" >> $GITHUB_ENV
          echo "no_proxy=localhost,127.0.0.1,192.168.0.0/16" >> $GITHUB_ENV
          git config --global --add http.proxy http://192.168.15.1:2345
          git config --global --add https.proxy http://192.168.15.1:2345

      - uses: actions/checkout@v2
        with:
          submodules: recursive

      - name: System and GPU info
        run: |
          set -xeuo pipefail
          uname -a
          nvidia-smi -L || true
          nvidia-smi || true
          which nvcc || true
          nvcc --version || true
          ldconfig -p | grep -i cuda || true

      - name: Detect GPU SM and set NVPTX target (CI-only)
        run: |
          set -e
          SM=$(nvidia-smi --query-gpu=compute_cap --format=csv,noheader 2>/dev/null | head -n1 | tr -d '.' || true)
          if [ -z "$SM" ]; then SM=52; fi
          echo "Using SM=sm_${SM} for NVPTXCompiler and trampoline/pass"
          sed -i -E "s/--gpu-name=sm_[0-9]{2}/--gpu-name=sm_${SM}/g" attach/nv_attach_impl/nv_attach_fatbin_record.cpp || true
          sed -i -E "s/sm_60/sm_${SM}/g" attach/nv_attach_impl/trampoline_ptx.h || true
          sed -i -E "s/sm_60/sm_${SM}/g" attach/nv_attach_impl/nv_attach_impl.cpp || true
          sed -i -E "s/sm_60/sm_${SM}/g" attach/nv_attach_impl/pass/ptxpass_kprobe_entry/main.cpp || true
          sed -i -E "s/sm_60/sm_${SM}/g" attach/nv_attach_impl/pass/ptxpass_kretprobe/main.cpp || true
          sed -i -E "s/sm_60/sm_${SM}/g" attach/nv_attach_impl/pass/ptxpass_kprobe_memcapture/main.cpp || true

      - name: Check and install required tools
        run: |
          echo "Checking installed tools..."
          sudo apt-get update -y
          sudo apt-get install -y build-essential llvm-dev llvm-18-dev cmake \
            libboost-all-dev libzstd-dev pkg-config ninja-build \
            libelf-dev zlib1g-dev libcurl4-openssl-dev \
            clang clang-18 gdb
          
          # Check CUDA
          nvcc --version || echo "nvcc not found (CUDA compiler)"
          echo "CUDA location: $(which nvcc)"

      - name: Build bpftime with CUDA support (LLVM JIT)
        shell: bash
        run: |
          set -e
          cmake -B build -S . \
            -DCMAKE_BUILD_TYPE=Debug \
            -DBPFTIME_LLVM_JIT=YES \
            -DBPFTIME_ENABLE_CUDA_ATTACH=ON \
            -DBPFTIME_CUDA_ROOT="/usr/local/cuda-12.6" \
            -DLLVM_DIR="/usr/lib/llvm-18/lib/cmake/llvm/" \
            -G Ninja
          set +e
          cmake --build build --config Debug --target bpftime-agent bpftime-syscall-server ptxpass_kprobe_entry ptxpass_kretprobe ptxpass_kprobe_memcapture -j$(nproc) --verbose -- -v | tee build_llvm_verbose.log
          BUILD_RC=${PIPESTATUS[0]}
          set -e
          if [ $BUILD_RC -ne 0 ]; then
            echo "Build failed. Showing last 300 lines of build_llvm_verbose.log:"
            tail -n 300 build_llvm_verbose.log || true
            exit $BUILD_RC
          fi

      - name: Build GPU example
        run: |
          echo "Building GPU example: ${{matrix.examples.path}}"
          # Prefer system clang; fallback to clang-18 if needed
          if ! command -v clang >/dev/null 2>&1 && command -v clang-18 >/dev/null 2>&1; then
            export CLANG=clang-18
          fi
          make -C example/gpu/${{matrix.examples.path}} -j

      - name: Test GPU example (per README two-process)
        shell: bash
        run: |
          set -xeuo pipefail
          ROOT_DIR=$(pwd)
          EXAMPLE_DIR="$ROOT_DIR/example/gpu/${{matrix.examples.path}}"
          BUILD_DIR="$ROOT_DIR/build"
          SERVER_SO="$BUILD_DIR/runtime/syscall-server/libbpftime-syscall-server.so"
          AGENT_SO="$BUILD_DIR/runtime/agent/libbpftime-agent.so"
          EXE="$EXAMPLE_DIR/${{ matrix.examples.executable }}"
          VICTIM="$EXAMPLE_DIR/${{ matrix.examples.victim }}"
          EXPECTED="${{ matrix.examples.expected_str }}"
          SERVER_TIMEOUT="${{ matrix.examples.server_timeout }}"
          CLIENT_TIMEOUT=45
          # Improve diagnostics: enable verbose logging and coredumps
          export SPDLOG_LEVEL=debug
          export BPFTIME_LOG_LEVEL=DEBUG
          ulimit -c unlimited || true
          # Try to set core_pattern so cores land in workspace with useful names
          if command -v sudo >/dev/null 2>&1; then
            echo 'core.%e.%p' | sudo tee /proc/sys/kernel/core_pattern >/dev/null || true
          fi
          echo "Launching server with $SERVER_SO: $EXE (BPFTIME_SHM_MEMORY_MB=16)"
          PRLIMIT_BIN=$(command -v prlimit || echo "")
          if [ -n "$PRLIMIT_BIN" ]; then
            CMD_PREFIX="$PRLIMIT_BIN --memlock=unlimited --nice=0 --"
          else
            CMD_PREFIX=""
          fi
          BPFTIME_SHM_MEMORY_MB=16 BPFTIME_LOG_OUTPUT=console LD_PRELOAD="$SERVER_SO" \
            $CMD_PREFIX "$EXE" > server.log 2>&1 &
          SERVER_PID=$!
          echo "Server PID: $SERVER_PID"
          # Wait a bit for server to come up
          sleep "$SERVER_TIMEOUT"
          if ! kill -0 "$SERVER_PID" 2>/dev/null; then
            echo "Server crashed early. Showing server.log tail:"; tail -n 200 server.log || true
            exit 1
          fi
          echo "Launching client with $AGENT_SO: $VICTIM"
          if [ -n "$PRLIMIT_BIN" ]; then
            $PRLIMIT_BIN --memlock=unlimited --nice=0 -- \
              timeout -s SIGKILL ${CLIENT_TIMEOUT}s env BPFTIME_LOG_OUTPUT=console LD_PRELOAD="$AGENT_SO" bash -lc "$VICTIM" > client.log 2>&1 || CLIENT_RC=$?
          else
            timeout -s SIGKILL ${CLIENT_TIMEOUT}s BPFTIME_LOG_OUTPUT=console LD_PRELOAD="$AGENT_SO" bash -lc "$VICTIM" > client.log 2>&1 || CLIENT_RC=$?
          fi
          CLIENT_RC=${CLIENT_RC:-0}
          echo "Checking expected output: $EXPECTED"
          # treat crashes as failure even if expected string appears
          if [ $CLIENT_RC -ne 0 ] || grep -Eiq "(core dumped|Segmentation fault|Aborted)" server.log client.log; then
            echo "Detected crash in logs"; tail -n 200 server.log || true; tail -n 200 client.log || true; RESULT=1
          elif grep -Fq "$EXPECTED" server.log client.log; then
            echo "SUCCESS: expected string found"
            RESULT=0
          else
            echo "FAILURE: expected string not found"
            echo "--- server.log (tail) ---"; tail -n 200 server.log || true
            echo "--- client.log (tail) ---"; tail -n 200 client.log || true
            RESULT=1
          fi
          # Try to collect core dumps (if generated)
          echo "Searching for core files..."
          CORE_FILES=$(ls -1 core* 2>/dev/null || true)
          if [ -n "$CORE_FILES" ]; then
            echo "Core files found: $CORE_FILES"
            if command -v gdb >/dev/null 2>&1; then
              for c in $CORE_FILES; do
                echo "--- GDB backtrace for $c ---" || true
                # Try to guess executable: prefer client victim if it crashed during client
                EXE_CANDIDATE="$VICTIM"
                if [ ! -x "$EXE_CANDIDATE" ]; then EXE_CANDIDATE="$EXE"; fi
                gdb -q -batch -ex "thread apply all bt full" -ex "quit" "$EXE_CANDIDATE" "$c" || true
              done
            fi
          fi
          # Dump recent dmesg for BPF/gpu hints
          dmesg | tail -n 200 > dmesg_tail.log 2>/dev/null || true
          kill $SERVER_PID 2>/dev/null || true
          exit $RESULT

      - name: Upload logs and cores
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: gpu-example-${{ matrix.examples.name }}-logs
          path: |
            server.log
            client.log
            dmesg_tail.log
            build_llvm_verbose.log
            core*
